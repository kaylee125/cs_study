## 2장: 데이터 통신

### 데이터통신(data communication)이란?

컴퓨터와 같은 통신 기능을 갖고 있는 두 개 이상의 communication devices 사이에서 동선이나 광섬유 혹은 무선 링크 등을 포함하는 전송미디어를 사용하여 정해진 규칙, 즉 **통신 프로토콜에 따라 데이터로 표현되는 정보를 교환하는 과정**


### 전송모드

- 병렬전송: 여러 전송라인을 통헤 여러 비트를 동시에 전송
    - 두 장치간 거리가 짧은 경우 일반적으로 사용
    - pc에서 프린터로 전송하는 것은 대표적인 병렬 전송
    - 긴 거리일 경우 장점을 상실
- 직렬전송: 하나의 라인을 이용해 하나씩 모든 비트를 보냄
    - 긴 거리일 경우 병렬전송에 비해 비용이 적게 들고 신뢰성은 증가하나 속도가 느림
    

![](https://velog.velcdn.com/images/leesh970930/post/21d2a74f-1166-4cad-8665-96825019663b/image.png)

​    

- 비동기식 전송
    - 한번에 한문자씩 보내거나 받는 방식
    - 문자비트(ascii경우 7비트)+시작비트(1bit)+정지비트(2bit)
    - 키보드와 프린터와 같은 느린 장치들을 위해 사용되며 높은 오버해드를 가짐
- 동기식 전송
    - 정해진 수 만큼의 문자들을 하나의 그룹(프레임)으로 만들어서 일시에 전송하는 방법
    - 동기식 전송은 일반적으로 비동기식 전송에 비해 도 빠름
      

![](https://velog.velcdn.com/images/leesh970930/post/7259643c-cfcb-4d35-9ecf-d4bfb6ef3124/image.png)


    - 바이트(문자) 기반 전송
        - 각 프레임을 바이트(문자)의 연속으로 간주하는 방식
        - BISYNC,PPP,DDCMP
        
    - 비트 기반 전송
        - 각 프레임을 비트의 연속으로 간주하는 방식
        - Flag: 프레임의 시작과 끝을 알리기 위해 플래그라고 하는 특수한 비트 패턴사용(01111110))
        - 인터넷에서의 이더넷과 HDLC

![](https://velog.velcdn.com/images/leesh970930/post/ca289747-b519-4fa1-9ed4-1c69005f936a/image.png)

- 비트스터핑
    - 비트기반 프레임 형식의 데이터필드에 플래그 비트패턴과 동일한 비트가 들어오게될 경우 수신측에서 이 부분을 프레임의 마지막으로 인식 →비트 스터핑으로 해결
    - 송신측:데이터 필드 내에 연속되는 5개의 1을 발견한다면 다섯 번째의 1 뒤에 0을 추가로 삽입
    - 수신측: 연속되는 5개의 1이 수신되고 다음 비트가 0이면, 수신측은 0을 비트스터핑 된 것이라고 간주하고 제거
    - 프레임의 시작과 끝에 위치한 플래그만 유일하게 연속되는 6개의 1이 포함
    

![](https://velog.velcdn.com/images/leesh970930/post/ad6959dc-4c93-4171-8376-311f5c7736e1/image.png)


​    
- 단방향,반이중,전이중
    - 단방향(simplex):한 방향으로만 신호 전송이 가능 ex. 프린터,TV방송
    - 반이중(half duplex):양쪽 방향에서 보내고 받을 수 있지만, 동시는 불가하고 교대로 전송
    - 전이중(full duplex):양쪽 호스트가 동시에 데이터전송 가능 ex.인터넷
- 교환기술
    - N개의 통신 장비 →N(N-1)/2개의 연결선이 필요
    - 해결방안으로 각각의 장비들은 통신망에 연결
    - 통신망을 효과적으로 운영하기 위해 교환기술을 사용함
    ![](https://velog.velcdn.com/images/leesh970930/post/574dd344-8195-478f-b30e-76706bb32817/image.png)

        - 회선교환
     <img src="https://velog.velcdn.com/images/leesh970930/post/302026b6-ac70-42f3-9bff-d7f1a53e6600/image.png" width="200" height="200">

<img src="https://velog.velcdn.com/images/leesh970930/post/9c1d7066-3bee-4248-9d58-1c9cc24cdcff/image.png" width="300" height="200">

- 다중화기술: 다수의 송신 호스트가 보내는 데이터를 하나의 전송매체를 통해 동시에 전송하는 기술
    - N개의 호스트가 전송매체의 대역폭을 공유하는 의미
    - TDM:time(시간)으로 대역폭을 분할

- 메시지 교환->실제로는 거의 사용 안함
	
	> 메시지라는 논리적인 단위로 전송
- 패킷 교환
	     
> - 회선교환,메세지 교환의 장점을 취하면서 만들어진 교환방식
 - 패킷이라는 단위로 데이터를 전송
  - 패킷:정해진 형식에 맞추어진 데이터 단위
  - 패킷에는 목적지 주소 및 패킷의 성격,형식 등의 정보가 저장
  - 두가지 방식(가상회선:virtual circuit/데이터그램)![](https://velog.velcdn.com/images/leesh970930/post/8d404355-82ef-4393-b516-f5e749d0f538/image.png)
  - 회선교환:물리적 회선 설정 후 데이터 전송
   - 가상회선:논리적인 회선 설정 후 **패킷 단위로 전송**, 수신측에서는 수신확인 패킷을 송신측에 전달
        - 과정:연결설정->데이터전송->연결해제(3단계)
        - 특징: 1)논리적인 가상회선을 설정 2)많은 양의 데이터를 안정적으로 전송할때 유리 3)하나의 물리적인 회선을 여러 개의 논리적인 회선으로 공유할 수 있는 경제성을 가짐
	- 예시:1) 각 패킷은 VCI(virtual circuit ID) 포함 2) 가상회선 설정시간에 경로가 설정 3) 각 라우터는 라우팅 테이블 유지  

    ![](https://velog.velcdn.com/images/leesh970930/post/d60f4d2c-3435-4aed-8c1f-50d182224cf8/image.png)
   - 데이터그램: 회선 설정없이(연결 설정 및 해제과정 없음) 패킷이 생기는대로 전송하는 방식
        - 하나의 패킷이 독립적으로 전송
        - 각 패킷이 각기 다른 경로를 가질 수 있으므로 보낸 순서와 다르게 수신측에 도착할 수 있음(수신측에서 재정렬해야하는 부담)
        - 적은 양의 데이터를 신속하게 보낼 때 유리함
      ![](https://velog.velcdn.com/images/leesh970930/post/79bbb399-b077-4d40-a1f3-cf42cf4e87b6/image.png)

​    

  

 - 오류검출과 교정기법
    	
   
   **1) 단순패리티 검사**
   - 패리티 비트를 각 문자 끝에 추가
    - 패리티비트: 자신을 포함하여 1의 개수가 짝수개이면 짝수패리티, 홀수개면 홀수 패리티
    ex.) 아스키코드 G(1110001)을 홀수 패리티를 사용해 전송하고 싶으면 1110001**1**을 전송해야함
    - 송신측 아스키코드를 홀수 패리티를 사용해 전송한다.
    ![](https://velog.velcdn.com/images/leesh970930/post/606ead83-06b7-40a5-9d14-62eed407f34f/image.png)
    > 송신측: 패리티 비트를 포함한 비트를 전송매체를 통해 수신측으로 전송
    >  수신측:1의 계수가 짝수개일 경우->데이터 거부
    >  1의 계수가 홀수개이면 ->데이터 수락
   
    **2) 2차원 패리티 검사**
    - 단순 패리티 검사는 오류를 검출하는데 한계가 있음
    - 2차원 패리티 검사는 문자의 비트를 2차원 배열로 구성하여 각 행과 열마다 패리티 비트를 계산
    - 2차원 패리티 검사는 3비트의 오류까지 검출할 수 있음
    >행과 열 방향에서 모두 짝수개의 오류가 발생하면 오류 검출 불가
    > ![](https://velog.velcdn.com/images/leesh970930/post/88c5ee55-d0a7-4705-9d7e-464a107f1ab9/image.png)
   
   
   

  **3) 책섬 오류검출 기법**
   	**송신측**
    - 데이터를 m비트의 세그먼트로 분리
    - m비트의 세그먼트들을 모두 더하고 난 후 1의 보수(0->1 ,1->0)를 수행한 값이 첵섬
    - 더하기를 하는 과정에서 가장 왼쪽 비트(MSB)에서의 캐리가 생기면 구해진 합에 더함
    **수신측**
     - 송신측에서 받은 모든 m비트의 세그먼트들과 함께 첵섬도 모두 더함
     - 만약 어떤 오류가 패킷에 있지 않다면 모두 더한 값은 m비트가 모두 1이 됨
     - **비트중의 하나라도 0이면 패킷에 오류**가 있다는 것을 의미![](https://velog.velcdn.com/images/leesh970930/post/57c4e5ce-9872-452c-9f5e-9a97ddfbba75/image.png) - 책섬값->seg 1~4합의 보수

>예제) 10101001 00111001의 책섬값은?
>합=11100010
>책섬값=합의 1의보수= 00011101

**4) 순환 중복 검사(CRC)**
	- 오류 검출에 주로 사용됨, 매우 강력하면서도 쉽게 구현할 수 있는 기술
    - 인터넷에 사용
   >![](https://velog.velcdn.com/images/leesh970930/post/0d9e69a7-f334-432b-87cd-8d4ec751f3d1/image.png)-FCS:frame check sequence 
   >	-(k+1)비트:생성다항식

 **CRC 동작과정**
  ![](https://velog.velcdn.com/images/leesh970930/post/f018119a-7d18-4aff-87f8-831a806113ce/image.png)


 **CRC 동작원리**
 - CRC연산:XOR 
 ![](https://velog.velcdn.com/images/leesh970930/post/3bf5f77a-4476-4397-aa58-7c855d813dde/image.png)
    ![](https://velog.velcdn.com/images/leesh970930/post/cd5dedee-c40c-4308-bca8-e0feea0c5cbc/image.png)

    

9/5=몫(1)+나머지(4)
- 송신측에서 실제로 전송되는 데이터![](https://velog.velcdn.com/images/leesh970930/post/932f2777-cc69-4b00-a855-bfa365ece151/image.png) R(x)=FCS
- 데이터가 올바르게 수신되었다고 가정하고, 수신측에서 G(x)로 나누었을때 나머지가 0이면 오류없이 올바르게 데이터가 수신되었다고 보면 됨.

> 예제) CRC에서 전송하려는 원래의 데이터와 생성 다항식이 다음과 같은 경우 FCS를 구하시오. 데이터:10111001 생성다항식: 10101
> ![](https://velog.velcdn.com/images/leesh970930/post/e650fde9-8287-4507-b31e-3144d6c4aab8/image.png)
> 풀이) 생성다항식이 5비트이기 때문에 데이터 뒤에 0000(4비트) 추가한 후 나누기->맨 앞에 값이 1인 경우 몫이 1이 올라가고 XOR연산 수행을 순차적으로 진행->더이상 나눌 수 없을때 FCS값 산출
> ->최종적으로 송신측에서 보내려고 한 데이터는 10111001+FCS 즉,101110010001이다. (나머지 값이 0이 아니면 에러 발생)

**5) 해밍코드(오류 교정 코드)**
	- N비트이 데이터에 k개의 패리티 비트를 더하여 (n+k)비트의 새로운 코드워드를 생성
    - 어떤 길이의 데이터어에도 사용 가능
    - 방법:
- 1)1비트 오류 정정 또는 2비트 오류 검출
- 2)N bit 데이터와 k개의 패리티 비트 사용한다고 할때 다음 수식이 성립되어야 함![](https://velog.velcdn.com/images/leesh970930/post/3390308d-e8b0-4195-a709-e7fc678d47f6/image.png)

>예시) N이 8 bit인 데이터의 경우
>->(2^k)-1>=8+k->  k>=4->k는 적은게 좋기 때문에 k=4


-수신측에서 신드롬을 계산, 신드롬이 표현하는 십진수가 오류발생의 위치를 나타냄 **-> 신드롬의 모든 비트가 "0"이면 오류 없음**


**해밍코드의 패리티 위치 및 계산**
-패리티비트가 추가된 위치

![](https://velog.velcdn.com/images/leesh970930/post/f29bfa7e-85a2-4033-8b5b-8cc1c51569fc/image.png)

![](https://velog.velcdn.com/images/leesh970930/post/3f48a95c-2769-422a-8347-83677560d96c/image.png)
-수신측:신드롬(c8c4c2c1)값의 십진수가 오류가 발생한 위치


>![](https://velog.velcdn.com/images/leesh970930/post/34915509-c850-4c2c-b2d3-82c06ac2a9ed/image.png)![](https://velog.velcdn.com/images/leesh970930/post/547f7987-9573-4569-a7aa-3c5da17bea54/image.png)




​    
​    

 